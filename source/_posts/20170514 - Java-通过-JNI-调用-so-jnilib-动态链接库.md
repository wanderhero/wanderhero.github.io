---
title: Java 通过 JNI 调用 so/jnilib 动态链接库  
categories: [Java,JNI]  
tags: [Java,JNI,so,jnilib]  
date: 2017-05-14 16:32:56
---
&emsp;&emsp;本文用的是 **JDK 1.7** 版本，使用 **Ubuntu 14.04.2 LTS** 编译 so，**macOS Sierra 10.12.4** 编译 jnilib。 
主要步骤就如下三步，具体代码见 [**https://github.com/wanderhero/test-normal-project.git**](https://github.com/wanderhero/test-normal-project)：  
&emsp;&emsp;1.加载实现了 native 函数的动态库；  
&emsp;&emsp;2.声明 native 函数；  
&emsp;&emsp;3.调用 native 函数。
``` bash
package com.wander.jni;

public class JNITest {
	static {
		System.loadLibrary("JNITest");// 加载实现了native函数的动态库
	}

	public static native String test(String name);// 声明native函数

	public static void main(String[] args) {
		System.out.println(test("wander"));// 调用 native 函数
	}
}
```
<!-- more -->
***
### 前言
&emsp;&emsp;首先还是要先了解下什么是 JNI，才能知己知彼，百战不殆。
其实关键问题在于如何生成动态链接库，Java 方面倒不是大问题。  
&emsp;&emsp;参考自 [xyang0917](#参考1)，JNI 全称是 Java Native Interface (Java本地接口) 单词首字母的缩写，本地接口就是指用 C 和 C++ 开发的接口。由于 JNI 是 JVM 规范中的一部份，因此可以将我们写的JNI 程序在任何实现了 JNI 规范的 Java 虚拟机中运行。同时，这个特性使我们可以复用以前用 C/C++ 写的大量代码。  
&emsp;&emsp;开发 JNI 程序会受到系统环境的限制，因为用 C/C++ 语言写出来的代码或模块，编译过程当中要依赖当前操作系统环境所提供的一些库函数，并和本地库链接在一起。而且编译后生成的二进制代码只能在本地操作系统环境下运行，因为不同的操作系统环境，有自己的本地库和 CPU 指令集，而且各个平台对标准 C/C++ 的规范和标准库函数实现方式也有所区别。这就造成使用了 JNI 接口的 JAVA 程序，不再像以前那样自由的跨平台。如果要实现跨平台，就必须将本地代码在不同的操作系统平台下编译出相应的动态库(**windows：#.dll, linux/unix：lib#.so, mac os x：lib#.jnilib**)。  
### 生成 C/C++ 代码
&emsp;&emsp;如果已有 C/C++ 文件，可跳过此步。  
&emsp;&emsp;最开始我们已经新建了一个 **JNITest.java** 源文件，那就基于此文件快速生成 .h 头文件。  
- **首先获取 .class 字节码文件，如果没有没有生成，可以通过javac 命令将 .java 源文件编译而成。**  
注意是在工程根目录下，-d 表示将编译后的 class 文件放到指定的目录下，这里我把它放到和 src 同级的 bin 目录下。

``` bash
192:test-normal-project wander$ javac src/com/wander/jni/JNITest.java -d ./bin
```
- **然后就可以用 javah -jni 命令，根据 class 字节码文件生成 .h 头文件。**  
默认生成的 .h 头文件名为 com_wander_jni_JNITest.h（包名+类名.h），我把它放在和 src 同级的 res/jni 目录下。    

``` bash
$ javah -jni -classpath ./bin -d ./res/jni com.wander.jni.JNITest
```
&emsp;&emsp;&emsp;也可以通过 -o 参数指定生成头文件名称，注意不能和 -d 混用，默认生成到同级目录下。
``` bash
$ javah -jni -classpath ./bin -o JNITest.h com.wander.jni.JNITest
```
&emsp;&emsp;&emsp;参数说明，注意：-d和-o只能使用其中一个参数，具体查看 **javah -help**：  
&emsp;&emsp;&emsp;&emsp;-classpath ：类搜索路径，这里表示从当前的 bin 目录下查找  
&emsp;&emsp;&emsp;&emsp;-d ：将生成的头文件放到当前的 res/jni 目录下  
&emsp;&emsp;&emsp;&emsp;-o ：指定生成的头文件名称  

&emsp;&emsp;&emsp;生成的 .h头文件如下：
``` bash
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_wander_jni_JNITest */

#ifndef _Included_com_wander_jni_JNITest
#define _Included_com_wander_jni_JNITest
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_wander_jni_JNITest
 * Method:    test
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_wander_jni_JNITest_test
  (JNIEnv *, jclass, jstring);

#ifdef __cplusplus
}
#endif
#endif
```
- **最后根据 .h头文件生成 .c 文件**  
此处我在 c 里面打印 **Hello ${name}**，同时返回 **return ${name}**

``` bash
// com_wander_jni_JNITest.c  
  
#include "com_wander_jni_JNITest.h"  
  
#ifdef __cplusplus  
extern "C"  
{  
#endif   
/*
 * Class:     com_wander_jni_JNITest
 * Method:    test
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_wander_jni_JNITest_test(  
        JNIEnv *env, jclass cls, jstring j_str) 
{  
    const char *c_str = NULL;  
    char buff[128] = { 0 };  
    c_str = (*env)->GetStringUTFChars(env, j_str, NULL);  
    if (c_str == NULL)  
    {  
        printf("out of memory.\n");  
        return NULL;  
    }  
    printf("Hello %s in c\n", c_str);  
    sprintf(buff, "return %s", c_str);  
    (*env)->ReleaseStringUTFChars(env, j_str, c_str);  
    return (*env)->NewStringUTF(env, buff);  
}  
#ifdef __cplusplus  
}  
#endif
```
### 将 C/C++ 代码编译成动态库文件
&emsp;&emsp;最近爆发了 比特币勒索病毒，三个操作系统的优劣好差估计又有谈资了。
- **Linux/Unix**  
参数说明：  
&emsp;-I：包含编译JNI必要的头文件  
&emsp;-fPIC：编译成与位置无关的独立代码  
&emsp;-shared：编译成动态库  
&emsp;-o：指定编译后动态库生成的路径和文件名  
本文用的是 阿里云的Ubuntu 14.04.2 LTS，把 .h 和 .c 文件放到同一目录下，通过 gcc 命令一步生成 libJNITest.so。

``` bash
$ gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared com_wander_jni_JNITest.c -o libJNITest.so
```
- **Mac OS X**  
参数说明：  
&emsp;-dynamiclib：表示编译成动态链接库  
&emsp;-o：指定动态链接库编译后生成的路径及文件名  
&emsp;-framework JavaVM -I：编译JNI需要用到JVM的头文件(jni.h)，第一个目录是平台无关的，第二个目录是与操作系统平台相关的头文件

``` bash
$ gcc -dynamiclib -o libJNITest.jnilib com_wander_jni_JNITest.c -framework JavaVM -I/$JAVA_HOME/include -I/$JAVA_HOME/include/darwin
```
&emsp;&emsp;&emsp;看上去也很简单，但是在我的电脑上却报错了，提示 **'jni.h' file not found(找不到 jni 头文件)**，感谢 [Stack Overflow](#参考2)，找到了貌似正确的命令，却提示 **Operation not permitted(不允许操作)**，连加了 sudo 都不行，难道我的人品差到连系统都不忍直视了吗？事实证明，人品是挺差的，但功夫不负有心人，感谢 [小胡子](#参考3)，原来 Apple 在 OS X 10.11 以后的版本中默认启动了一项系统保护程序，叫做 System Integrity Protection，也被唤作 rootless（寓意让 root 弱一点），该程序意在保护电脑不被恶意程序攻击，感觉屌屌的，以安全的名义，一切都是可以接受的。  
&emsp;&emsp;&emsp;SIP 会锁定几个系统文件目录：
``` bash
/System
/sbin
/usr （/usr/local 除外）
```
&emsp;&emsp;&emsp;在 SIP 的保护下，部分软件、功能、脚本都会失效，还好 mac 提供了命令，我们可以通过 csrutil 来检测系统当前 SIP 的启动状态、打开或关闭此功能。
``` bash
$ csrutil status
System Integrity Protection status: enabled.
```
&emsp;&emsp;&emsp;enabled 说明当前我的系统是在 SIP 保护下的，我们可以通过如下步骤关闭 SIP，以防万一，可以先做个 Time Machine 备份：  
&emsp;&emsp;&emsp;&emsp;- 重启电脑，按下 Command + R 直到听到开机声音，此时电脑会进入恢复模式（Recovery Mode）  
&emsp;&emsp;&emsp;&emsp;- 当 macOS 实用工具出现在屏幕中时，选择 实用工具(Utilities) 菜单，选择 终端(Terminal)  
&emsp;&emsp;&emsp;&emsp;- 输入 csrutil disable，回车
&emsp;&emsp;&emsp;&emsp;- 电脑重启后，SIP 就关闭了  
&emsp;&emsp;&emsp;恢复 SIP 的方式同上，只不过终端中输入 csrutil enable 即可。
<div style="float: left">[![](http://wander.u.qiniudn.com/20170514-1632-0.0.jpg?imageView2/2/h/140/imageslim)](http://wander.u.qiniudn.com/20170514-1632-0.0.jpg?imageslim)</div>[![](http://wander.u.qiniudn.com/20170514-1632-0.1.jpg?imageView2/2/h/140/imageslim)](http://wander.u.qiniudn.com/20170514-1632-0.1.jpg?imageslim)    

&emsp;&emsp;&emsp;关闭了 SIP 后，再来试试之前的 jni 头文件找不到的问题，果然 OK，这里我采用的是 jdk1.7 版本：  
``` bash
$ cd /System/Library/Frameworks/JavaVM.framework/Versions
$ sudo ln -nsf /Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents ./CurrentJDK

$ cd /System/Library/Frameworks/JavaVM.framework
$ sudo ln -nsf Versions/CurrentJDK/Home/include/ ./Headers
```
&emsp;&emsp;&emsp;问题扫除后，再执行 gcc 命令，libJNITest.jnilib 顺利生成~
- **Windows**
由于手上没有 Windows 电脑，Windows 的验证暂缺。

### 运行 Java 程序
&emsp;&emsp;经过了漫长的准备，动态链接库 终于到手，接下来就差最后一把火了。此时如果心急直接运行，程序会毫不留情地抛给你一个 java.lang.UnsatisfiedLinkError 异常，且无法 try catch。
``` bash
Exception in thread "main" java.lang.UnsatisfiedLinkError: no JNITest1 in java.library.path
	at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1886)
	at java.lang.Runtime.loadLibrary0(Runtime.java:849)
	at java.lang.System.loadLibrary(System.java:1088)
	at com.wander.jni.JNITest.<clinit>(JNITest.java:5)
```
&emsp;&emsp;一般在类的静态 (static) 代码块中加载动态库最合适，因为在创建类的实例时，类会被 ClassLoader 先加载到虚拟机，随后立马调用类的 static 静态代码块。这时再去调用 native 方法就万无一失了。加载动态库的两种方式：  
&emsp;&emsp;方法1简单粗暴，指定要调用的动态链接库的绝对路径即可，只是在跨平台访问时，需要指定对应平台的文件路径，且不同平台文件的前缀和后缀都不一样；
``` bash
System.load("/Users/wander/MyDocuments/workspace/workspace4eclipse/test-normal-project/res/jni/libJNITest.jnilib");
```
&emsp;&emsp;方法2只需要指定动态库的名字即可，不需要前缀后缀，java 会去 java.library.path 系统属性指定的目录下查找动态库文件，一劳永逸；
``` bash
System.loadLibrary("JNITest");
```
&emsp;&emsp;这里我写了一个简单类去查看 java.library.path 路径，和环境变量一样，每个路径用:分割，随便放到哪个路径下都有效。
``` bash
package com.wander.jni;

public class JavaLibraryPath {
	public static void main(String[] args) {
		System.out.println(System.getProperty("java.library.path"));
	}
}
```
&emsp;&emsp;做成可执行 Jar 文件，就可以在多平台上运行查看了。
``` bash
$ java -jar JavaLibraryPath.jar
/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib
```
&emsp;&emsp;如此这般，就可以再做个可执行 Jar 文件，在 linux/unix 平台上访问了，mac 系统更是可以在 IDE 里面运行调试了。
``` bash
$ java -jar JNITest.jar 
Hello wander in c
return wander
```
### 总结
&emsp;&emsp;不会 C/C++ 的 Java 程序员也可以用好 JNI~
### 参考 
- <span id="参考1">[JNI/NDK开发指南（一）—— JNI开发流程及HelloWorld](http://blog.csdn.net/xyang81/article/details/41777471)</span>  
- <span id="参考2">[Stack Overflow - How to install Java native development headers on OS X Lion](http://stackoverflow.com/questions/9704376/how-to-install-java-native-development-headers-on-os-x-lion)</span> 
- <span id="参考3">[小胡子哥的个人博客 - Unix/Linux 系统中的 Operation Not Permitted 问题](http://www.barretlee.com/blog/2016/04/06/operation-not-permitted-problem-in-linux-or-unix-system/)</span> 